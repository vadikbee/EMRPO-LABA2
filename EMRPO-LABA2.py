import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Конфигурация страницы ---
st.set_page_config(
    page_title="Лабораторная работа №2 | Временная сложность",
    page_icon="⏱️",
    layout="wide"
)

# --- Стилизация (ТЁМНАЯ ТЕМА) ---
st.markdown("""
<style>
    /* Основной фон и текст */
    .stApp {
        background-color: #0E1117; /* Темный фон Streamlit по умолчанию */
        color: #FAFAFA; /* Светлый текст */
    }
    /* Заголовки */
    h1, h2, h3 {
        color: #00FF7F; /* Яркий зеленый для акцента */
    }
    /* Боковая панель */
    .css-1d391kg {
        background-color: #1F222B; /* Чуть светлее основного фона */
        border-right: 2px solid #00FF7F;
    }
    /* Информационные блоки */
    .stAlert {
        border-radius: 10px;
        border: 1px solid #00FF7F;
        background-color: #1F222B;
    }
    /* Таблицы Pandas */
    .dataframe-container {
        background-color: #0E1117;
    }
</style>
""", unsafe_allow_html=True)

# --- Настройка стиля для графиков Matplotlib (ТЁМНАЯ ТЕМА) ---
plt.style.use('dark_background')
plt.rc('figure', facecolor='#0E1117', edgecolor='#00FF7F')
plt.rc('axes', facecolor='#1F222B', edgecolor='gray', labelcolor='white', titlecolor='#00FF7F')
plt.rc('xtick', color='white')
plt.rc('ytick', color='white')
plt.rc('legend', facecolor='#1F222B', edgecolor='gray')


# --- ОСНОВНАЯ ЧАСТЬ ПРИЛОЖЕНИЯ ---

st.sidebar.title("Навигация по работе")
app_mode = st.sidebar.selectbox(
    "Выберите раздел:",
    [
        "Введение и постановка задачи",
        "Анализ алгоритма: Сортировка вставками",
        "Анализ алгоритма: Правило Горнера",
        "Анализ алгоритма: Умножение матриц (Штрассен)",
        "Задание: Алгоритмы Маркова" # Новый раздел
    ]
)

if app_mode == "Введение и постановка задачи":
    st.title("⏱️ Лабораторная работа №2: Временная сложность алгоритма")
    st.info("Этот Streamlit-отчет представляет собой интерактивное выполнение заданий из методического указания по теме анализа временной сложности.")

    st.header("Цели работы:")
    st.markdown("""
    - **Изучить** понятие временной сложности и методы её анализа.
    - **Научиться доказывать** корректность работы алгоритмов с помощью инвариантов цикла.
    - **Освоить** асимптотический анализ сложности для рекурсивных и итеративных алгоритмов.
    - **Применить** различные методы анализа (метод подстановки, метод дерева рекурсии, основной метод) для оценки сложности конкретных алгоритмов.
    """)

    st.header("Задачи к лабораторной работе:")
    st.markdown("""
    Для заданных алгоритмов (в соответствии с вариантом):
    1.  **Написать программу** (в виде псевдокода или на любом языке программирования).
    2.  **Доказать инвариант цикла** для итеративных алгоритмов.
    3.  **Доказать асимптотическую сложность** реализованного алгоритма следующими способами:
        - Методом анализа псевдокода (подсчет операций).
        - Методом подстановки (для рекурсивных алгоритмов).
        - Методом деревьев рекурсии (для рекурсивных алгоритмов).
        - Основным методом (Master Theorem) (для рекурсивных алгоритмов).
    """)
    st.subheader("Варианты алгоритмов:")
    st.markdown("""
    - **Сортировка вставками** (Insertion Sort)
    - **Правило Горнера** для вычисления многочлена
    - **Умножение двух матриц** (в данной работе реализован **алгоритм Штрассена**)
    """)


elif app_mode == "Анализ алгоритма: Сортировка вставками":
    st.header("Анализ алгоритма: Сортировка вставками (Insertion Sort)")

    st.subheader("1. Псевдокод алгоритма")
    st.code("""
INSERTION-SORT(A)
1 for j = 2 to A.length
2     key = A[j]
3     // Вставка A[j] в отсортированную последовательность A[1..j-1]
4     i = j - 1
5     while i > 0 and A[i] > key
6         A[i+1] = A[i]
7         i = i - 1
8     A[i+1] = key
    """, language='plaintext')

    st.subheader("2. Доказательство инварианта цикла")
    st.markdown("""
    **Инвариант цикла:** В начале каждой итерации внешнего цикла `for` (строки 1-8) подмассив `A[1..j-1]` содержит те же элементы, что и исходно, но в отсортированном порядке.
    """)
    st.markdown("""
    - **Инициализация:** Перед первой итерацией `j=2`. Подмассив `A[1..1]` состоит из одного элемента, который, очевидно, является отсортированным. Условие выполняется.

    - **Сохранение:** Допустим, что перед итерацией с некоторым значением `j` подмассив `A[1..j-1]` отсортирован. В теле цикла (строки 4-7) внутренний цикл `while` сдвигает элементы `A[j-1], A[j-2], ...` вправо до тех пор, пока не найдет правильную позицию для `key` (исходного `A[j]`). Затем `key` вставляется на свое место (строка 8). В результате подмассив `A[1..j]` будет содержать те же элементы, что и до итерации, но уже в отсортированном порядке. Когда `j` увеличится на 1 в следующей итерации, инвариант для нового, увеличенного подмассива `A[1..j-1]` снова будет истинным.

    - **Завершение:** Цикл завершается, когда `j` становится равным `A.length + 1`. В этот момент, согласно инварианту, подмассив `A[1..A.length]` содержит исходные элементы в отсортированном порядке. Это означает, что весь массив отсортирован, и алгоритм работает корректно.
    """)

    st.subheader("3. Анализ асимптотической сложности")
    st.markdown("""
    Анализ основан на подсчете элементарных операций в псевдокоде. Время выполнения каждой строки `i` обозначим как константу `c_i`.
    """)
    df_data = {
        'Строка': ['1: for j = 2 to n', '2: key = A[j]', '4: i = j - 1', '5: while ...', '6: A[i+1] = A[i]', '7: i = i - 1', '8: A[i+1] = key'],
        'Стоимость': ['c₁', 'c₂', 'c₄', 'c₅', 'c₆', 'c₇', 'c₈'],
        'Повторения': ['n', 'n-1', 'n-1', 'Σ(tⱼ) for j=2 to n', 'Σ(tⱼ-1) for j=2 to n', 'Σ(tⱼ-1) for j=2 to n', 'n-1']
    }
    df = pd.DataFrame(df_data)
    st.table(df)
    st.markdown("""
    где `n = A.length`, а `tⱼ` — это количество проверок условия в цикле `while` для данного `j`.
    """)

    st.markdown("""
    **Худший случай:**
    Худший случай наступает, когда массив отсортирован в обратном порядке. В этом случае для каждого `j` элемент `key` приходится сравнивать со всеми элементами в отсортированном подмассиве `A[1..j-1]`. Таким образом, `tⱼ = j`.
    """)
    st.latex(r'''
    T(n) = c_1 n + c_2(n-1) + c_4(n-1) + c_5 \sum_{j=2}^{n} j + c_6 \sum_{j=2}^{n} (j-1) + c_7 \sum_{j=2}^{n} (j-1) + c_8(n-1)
    ''')
    st.markdown("Суммы вычисляются как `n(n+1)/2 - 1` и `(n-1)n/2` соответственно. После упрощения получаем:")
    st.latex(r'''
    T(n) = \left(\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2}\right)n^2 + \left(c_1+c_2+c_4+\frac{c_5}{2}-\frac{c_6}{2}-\frac{c_7}{2}+c_8\right)n - (c_2+c_4+c_5)
    ''')
    st.markdown("""
    Это квадратичная функция от `n` вида `an² + bn + c`. Следовательно, асимптотическая сложность в худшем случае:
    """)
    st.success(r'$T(n) = \Theta(n^2)$')

elif app_mode == "Анализ алгоритма: Правило Горнера":
    st.header("Анализ алгоритма: Правило Горнера")

    st.subheader("1. Псевдокод алгоритма")
    st.markdown("Правило Горнера используется для эффективного вычисления значения многочлена:")
    st.latex(r"P(x) = a_n x^n + a_{n-1}x^{n-1} + \dots + a_1 x + a_0")
    st.markdown("Его можно представить в виде:")
    st.latex(r"P(x) = a_0 + x(a_1 + x(a_2 + \dots + x(a_{n-1} + a_n x)\dots))")
    st.code("""
HORNER(A, x) // A - массив коэффициентов [a_0, a_1, ..., a_n]
1 y = 0
2 i = n
3 while i >= 0
4     y = A[i] + x * y
5     i = i - 1
6 return y
    """, language='plaintext')

    st.subheader("2. Доказательство инварианта цикла")
    st.markdown(r"""
    **Инвариант цикла:** В начале каждой итерации цикла `while` (строки 3-5), `y` равно значению многочлена, составленного из коэффициентов `A[i+1...n]` с переменной `x`. То есть:
    $y = \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k$
    """)
    st.markdown("""
    - **Инициализация:** Перед первой итерацией `i = n` и `y = 0`. Инвариант утверждает, что `y` равно значению многочлена с коэффициентами `A[n+1...n]`. Это пустой набор коэффициентов, и значение такого многочлена равно 0. Условие выполняется.

    - **Сохранение:** Допустим, перед итерацией с некоторым `i` инвариант истинен. В теле цикла (строка 4) `y` обновляется: `y_new = A[i] + x * y_old`.
    Подставим значение `y_old` из инварианта:
    $y_{new} = a_i + x \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + \sum_{k=0}^{n-i-1} a_{k+i+1} x^{k+1}$
    Сделаем замену `j = k+1`:
    $y_{new} = a_i + \sum_{j=1}^{n-i} a_{j+i} x^j = \sum_{j=0}^{n-i} a_{j+i} x^j$.
    Это в точности значение многочлена для коэффициентов `A[i...n]`. На следующей итерации `i` уменьшится на 1, и инвариант снова будет истинным для нового `i`.

    - **Завершение:** Цикл завершается, когда `i = -1`. Согласно инварианту, `y` равно значению многочлена с коэффициентами `A[0...n]`, что является исходным многочленом $P(x)$. Алгоритм работает корректно.
    """)

    st.subheader("3. Анализ асимптотической сложности")
    st.markdown("""
    Это простой итеративный алгоритм. Цикл `while` выполняется `n+1` раз (для `i` от `n` до `0`). Внутри цикла выполняются одна операция умножения и одна операция сложения, которые занимают константное время `c`.
    """)
    st.latex(r"T(n) = \sum_{i=0}^{n} c = c \cdot (n+1)")
    st.markdown("""
    Рост времени выполнения линейно зависит от `n` (степени многочлена). Следовательно, асимптотическая сложность:
    """)
    st.success(r'$T(n) = \Theta(n)$')


elif app_mode == "Анализ алгоритма: Умножение матриц (Штрассен)":
    st.header("Анализ алгоритма: Умножение матриц (метод Штрассена)")

    st.subheader("1. Псевдокод и описание алгоритма")
    st.markdown(r"""
    Алгоритм Штрассена — это рекурсивный алгоритм умножения матриц, основанный на принципе "разделяй и властвуй". Он позволяет перемножить две матрицы $n \times n$ быстрее, чем стандартный алгоритм со сложностью $\Theta(n^3)$.

    **Шаг 1: Разделение**
    Если размер матриц $n > 1$, то матрицы A, B и C (где $C = A \cdot B$) делятся на четыре подматрицы размером $(n/2) \times (n/2)$ каждая:
    """)
    st.latex(r'''
    A = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix}, \quad
    B = \begin{pmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \end{pmatrix}, \quad
    C = \begin{pmatrix} C_{11} & C_{12} \\ C_{21} & C_{22} \end{pmatrix}
    ''')

    st.markdown(r"""
    **Шаг 2: Вычисление промежуточных матриц**
    Ключевая идея Штрассена — выполнить только **7** рекурсивных умножений вместо 8, как в стандартном рекурсивном подходе. Для этого вычисляются 7 промежуточных матриц $P_1, \dots, P_7$ размером $(n/2) \times (n/2)$:
    """)
    st.latex(r'''
    P_1 = A_{11} \cdot (B_{12} - B_{22}) \\
    P_2 = (A_{11} + A_{12}) \cdot B_{22} \\
    P_3 = (A_{21} + A_{22}) \cdot B_{11} \\
    P_4 = A_{22} \cdot (B_{21} - B_{11}) \\
    P_5 = (A_{11} + A_{22}) \cdot (B_{11} + B_{22}) \\
    P_6 = (A_{12} - A_{22}) \cdot (B_{21} + B_{22}) \\
    P_7 = (A_{11} - A_{21}) \cdot (B_{11} + B_{12})
    ''')
    st.markdown("Эти шаги требуют 10 сложений и вычитаний матриц размера $(n/2) \times (n/2)$.")

    st.markdown(r"""
    **Шаг 3: Комбинирование**
    Результаты $C_{ij}$ вычисляются путем сложения и вычитания промежуточных матриц $P_i$:
    """)
    st.latex(r'''
    C_{11} = P_5 + P_4 - P_2 + P_6 \\
    C_{12} = P_1 + P_2 \\
    C_{21} = P_3 + P_4 \\
    C_{22} = P_5 + P_1 - P_3 - P_7
    ''')
    st.markdown("Этот шаг требует 8 сложений и вычитаний матриц размера $(n/2) \times (n/2)$.")

    st.subheader("2. Анализ асимптотической сложности")
    st.markdown(r"""
    Поскольку алгоритм рекурсивный, его временная сложность описывается рекуррентным соотношением.

    - **7** рекурсивных вызовов для умножения матриц размера $(n/2) \times (n/2)$. Время: $7 \cdot T(n/2)$.
    - **18** операций сложения/вычитания матриц размера $(n/2) \times (n/2)$. Сложение двух матриц $k \times k$ занимает $\Theta(k^2)$ времени. Таким образом, эти операции занимают $18 \cdot \Theta((n/2)^2) = \Theta(n^2)$.

    Рекуррентное соотношение для времени работы алгоритма Штрассена:
    """)
    st.latex(r"T(n) = 7 \cdot T(n/2) + \Theta(n^2)")

    st.markdown("---")
    st.subheader("Метод дерева рекурсии")
    st.markdown(r"""
    Построим дерево рекурсии для анализа соотношения $T(n) = 7T(n/2) + cn^2$.
    - **Корень (уровень 0):** Имеет стоимость $cn^2$.
    - **Уровень 1:** 7 дочерних узлов, каждый для подзадачи размера $n/2$. Стоимость каждого узла $c(n/2)^2$. Общая стоимость уровня: $7 \cdot c(n/2)^2 = \frac{7}{4}cn^2$.
    - **Уровень i:** $7^i$ узлов, каждый для подзадачи размера $n/2^i$. Общая стоимость уровня: $7^i \cdot c(n/2^i)^2 = (\frac{7}{4})^i cn^2$.
    - **Глубина дерева:** $k = \log_2 n$.
    - **Количество листьев:** $7^{\log_2 n} = n^{\log_2 7}$. Стоимость в листьях (базовый случай) $T(1) \cdot n^{\log_2 7} = \Theta(n^{\log_2 7})$.

    Полная стоимость — это сумма стоимостей на всех уровнях:
    """)
    st.latex(r'''
    T(n) = \sum_{i=0}^{\log_2 n - 1} \left(\frac{7}{4}\right)^i cn^2 + \Theta(n^{\log_2 7})
    ''')
    st.markdown(r"""
    Это возрастающая геометрическая прогрессия, поэтому итоговая стоимость определяется стоимостью на последнем уровне (в листьях).
    """)
    st.latex(r'''
    T(n) = \Theta(n^{\log_2 7})
    ''')

    st.markdown("---")
    st.subheader("Основной метод (Master Theorem)")
    st.markdown(r"""
    Применим основной метод к соотношению $T(n) = 7T(n/2) + \Theta(n^2)$.
    - $a = 7$
    - $b = 2$
    - $f(n) = \Theta(n^2)$

    Вычислим $n^{\log_b a}$:
    """)
    st.latex(r"n^{\log_2 7} \approx n^{2.807}")
    st.markdown(r"""
    Сравним $f(n) = n^2$ с $n^{2.807}$. Нам нужно проверить, выполняется ли $f(n) = O(n^{\log_2 7 - \epsilon})$ для некоторого $\epsilon > 0$.
    Выберем $\epsilon = 0.8$. Тогда $n^{\log_2 7 - \epsilon} \approx n^{2.007}$.
    Так как $f(n) = n^2 = O(n^{2.007})$, мы находимся в **первом случае** основной теоремы.

    Следовательно, решение:
    """)
    st.latex(r"T(n) = \Theta(n^{\log_b a}) = \Theta(n^{\log_2 7})")
    st.success(r"$T(n) = \Theta(n^{\log_2 7}) \approx \Theta(n^{2.807})$")
    st.info("Это значительно лучше, чем $\Theta(n^3)$ для стандартного алгоритма умножения, особенно на больших матрицах.")

elif app_mode == "Задание: Алгоритмы Маркова":
    st.header("Задание: Решение задач с помощью Алгоритмов Маркова")

    st.subheader("1. Алгоритм для извлечения квадратного корня")

    st.info("""
    **Идея:** Алгоритм основан на свойстве квадратов чисел: $n^2 = 1 + 3 + 5 + \dots + (2n-1)$.
    Чтобы найти квадратный корень из числа $N$, мы будем последовательно вычитать из него нечетные числа (1, 3, 5, ...), пока остаток не станет меньше следующего вычитаемого. Количество успешных вычитаний и будет целой частью квадратного корня.
    """)

    st.markdown("""
    **Представление данных:** Числа представляются в унарной системе счисления с помощью символа `|`. Например, число 9 — это `|||||||||`.

    **Описание работы алгоритма:**
    - **Состояние:** Строка имеет вид `[Остаток числа] [Результат] [Текущее нечетное число]`. Для разделения используются специальные символы.
    - **Начало:** К исходной строке `|||...|` (число N) добавляется маркер `*` и счетчик результата `a`.
    - **Цикл:**
        1. К счетчику результата `a` добавляется `|`, формируя очередное нечетное число для вычитания.
        2. Происходит посимвольное вычитание: одна `|` убирается из остатка числа, одна `|` — из нечетного числа.
        3. Если вычитание прошло успешно (число не кончилось), результат увеличивается на `|`, и процесс повторяется с новым, увеличенным на 2 нечетным числом.
        4. Если вычитание невозможно (число меньше очередного нечетного), работа алгоритма завершается.
    """)

    st.subheader("Формальный алгоритм")
    st.markdown("**Алфавит:** `{ |, *, a, b }`")
    st.markdown("**Входная строка:** `*` и `n` символов `|`. Пример для 9: `*|||||||||`")
    st.code("""
# 1. Начальная расстановка
* -> a*

# 2. Добавляем очередное нечетное число (в виде 'b')
a -> ba|

# 3. Переносим 'a' вправо
|a -> a|

# 4. Вычитание
b*| -> *

# 5. Переносим 'b' влево
|b -> b|

# 6. Конечное правило: если вычитание не удалось,
# 'b' дойдет до начала. Удаляем остаток.
b -> .

# 7. Очистка
* -> ""
| -> ""
    """, language='plaintext')

    st.subheader("Пример по шагам для N=9 (`*|||||||||`)")
    st.code("""
*||||||||| -> a*||||||||| (1)
 -> ba|*||||||||| (2)
 -> b*|||||||| (4) -> *||||||| (7) # Вычли 1, результат 1
 -> a*||||||| (1) -> ba|*||||||| (2) -> baa|*||||||| (2,3) -> baaa|*||||||| (2,3) # Формируем 3
 -> baa*|||||| (4) -> ba*||||| (4) -> b*|||| (4) # Вычитаем 3
 -> *||| (7) # Вычли 3, результат 2
 -> a*||| (1) -> ... # Формируем 5
 -> b* (4) -> * (7) # Вычли 5, результат 3
 -> a* (1) -> ... # Формируем 7, но число кончилось
 -> ... (сработает правило 6) -> ||| (Итоговый результат)
    """, language='plaintext')

    st.markdown("---")

    st.subheader("2. Алгоритм для умножения двух обыкновенных дробей")
    st.info("""
    **Идея:** Процесс состоит из двух основных этапов:
    1.  **Умножение:** Числитель первой дроби умножается на числитель второй, а знаменатель — на знаменатель. Получается новая, несокращенная дробь.
    2.  **Сокращение:** Для полученной дроби находится Наибольший Общий Делитель (НОД) числителя и знаменателя. Затем и числитель, и знаменатель делятся на этот НОД.
    """)
    st.markdown("""
    Реализация полного цикла в виде одного алгоритма Маркова очень громоздка. Поэтому задачу целесообразно разбить на три шага, для каждого из которых существует свой алгоритм:
    - **Умножение** (`a * b`)
    - **Нахождение НОД** (`GCD(a, b)`)
    - **Деление** (`a / b`)

    Ниже приведены алгоритмы для нахождения НОД и деления, которые являются ключевыми для решения задачи.
    """)

    st.subheader("Шаг 1: Умножение")
    st.markdown("""
    Входная строка `(a/b)*(c/d)` сначала преобразуется к виду, удобному для вычислений, например, `a#b#c#d#`. Затем с помощью стандартного алгоритма умножения (основанного на многократном сложении) вычисляются `a*c` и `b*d`. Результатом этого шага будет новая дробь `N/M`.
    """)

    st.subheader("Шаг 2: Сокращение (Нахождение НОД и Деление)")
    st.markdown("""
    Для сокращения дроби `N/M` нужно найти `D = GCD(N, M)`, а затем вычислить `(N/D)` и `(M/D)`.
    """)
    st.markdown("**Алгоритм Нахождения НОД (Евклид, через вычитание)**")
    st.markdown("Находит НОД для двух чисел, разделенных `/`.")
    st.markdown("**Вход:** `||||||/||||` (6/4)")
    st.markdown("**Выход:** `||` (2)")
    st.code("""
# Алфавит: { |, /, a, b, c }

# Этап 1: Вычитание a-b
/| -> /a
|/ -> /
a -> |

# Этап 2: Обработка случая, когда a < b
/ -> b/
b| -> |b
b/ -> /c
c -> ""

# Этап 3: Зацикливание. Если остаток не ноль, повторяем.
|/ -> |/| # Это условное правило для повторения.

# Конечное правило
/ -> .
    """, language="plaintext")

    st.markdown("**Алгоритм Деления**")
    st.markdown("Вычисляет `a / b`. Результат записывается слева от `*`.")
    st.markdown("**Вход:** `||||||/|||` (6/3)")
    st.markdown("**Выход:** `||*` (2)")
    st.code("""
# Алфавит: { |, /, *, a, b }

# 1. Инициализация
-> *

# 2. Перенос делимого (a) вправо от *, по одному символу
|* -> *a

# 3. Восстановление символа | из a
a -> |

# 4. Основной цикл вычитания
*|/| -> b*/
b| -> |b
b/ -> /a

# 5. Увеличение результата
a -> |*

# 6. Очистка
/ -> ""
* -> *
    """, language="plaintext")
    st.success("**Итог:** Для получения конечного результата необходимо последовательно применить алгоритмы: дважды умножение, затем НОД, и дважды деление. Это демонстрирует, как сложные задачи решаются путем комбинации более простых алгоритмических блоков.")