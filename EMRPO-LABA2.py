import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# --- Конфигурация страницы ---
st.set_page_config(
    page_title="Лабораторная работа №2 | Временная сложность",
    page_icon="⏱️",
    layout="wide"
)

# --- Стилизация (ТЁМНАЯ ТЕМА) ---
st.markdown("""
<style>
    /* Основной фон и текст */
    .stApp {
        background-color: #0E1117; /* Темный фон Streamlit по умолчанию */
        color: #FAFAFA; /* Светлый текст */
    }
    /* Заголовки */
    h1, h2, h3 {
        color: #00FF7F; /* Яркий зеленый для акцента */
    }
    /* Боковая панель */
    .css-1d391kg {
        background-color: #1F222B; /* Чуть светлее основного фона */
        border-right: 2px solid #00FF7F;
    }
    /* Информационные блоки */
    .stAlert {
        border-radius: 10px;
        border: 1px solid #00FF7F;
        background-color: #1F222B;
    }
    /* Таблицы Pandas */
    .dataframe-container {
        background-color: #0E1117;
    }
</style>
""", unsafe_allow_html=True)

# --- Настройка стиля для графиков Matplotlib (ТЁМНАЯ ТЕМА) ---
plt.style.use('dark_background')
plt.rc('figure', facecolor='#0E1117', edgecolor='#00FF7F')
plt.rc('axes', facecolor='#1F222B', edgecolor='gray', labelcolor='white', titlecolor='#00FF7F')
plt.rc('xtick', color='white')
plt.rc('ytick', color='white')
plt.rc('legend', facecolor='#1F222B', edgecolor='gray')

# --- ОСНОВНАЯ ЧАСТЬ ПРИЛОЖЕНИЯ ---

st.sidebar.title("Навигация по работе")
app_mode = st.sidebar.selectbox(
    "Выберите раздел:",
    [
        "Введение и постановка задачи",
        "Анализ алгоритма: Сортировка вставками",
        "Анализ алгоритма: Правило Горнера",
        "Анализ алгоритма: Умножение матриц (Штрассен)",
        "Домашнее задание: Решение рекуррентных соотношений"  # <-- НОВЫЙ РАЗДЕЛ
    ]
)

if app_mode == "Введение и постановка задачи":
    st.title("⏱️ Лабораторная работа №2: Временная сложность алгоритма")
    st.info(
        "Этот Streamlit-отчет представляет собой интерактивное выполнение заданий из методического указания по теме анализа временной сложности.")

    st.header("Цели работы:")
    st.markdown("""
    - **Изучить** понятие временной сложности и методы её анализа.
    - **Научиться доказывать** корректность работы алгоритмов с помощью инвариантов цикла.
    - **Освоить** асимптотический анализ сложности для рекурсивных и итеративных алгоритмов.
    - **Применить** различные методы анализа (метод подстановки, метод дерева рекурсии, основной метод) для оценки сложности конкретных алгоритмов.
    """)

    st.header("Задачи к лабораторной работе:")
    st.markdown("""
    Для заданных алгоритмов (в соответствии с вариантом):
    1.  **Написать программу** (в виде псевдокода или на любом языке программирования).
    2.  **Доказать инвариант цикла** для итеративных алгоритмов.
    3.  **Доказать асимптотическую сложность** реализованного алгоритма следующими способами:
        - Методом анализа псевдокода (подсчет операций).
        - Методом подстановки (для рекурсивных алгоритмов).
        - Методом деревьев рекурсии (для рекурсивных алгоритмов).
        - Основным методом (Master Theorem) (для рекурсивных алгоритмов).
    """)
    st.subheader("Варианты алгоритмов:")
    st.markdown("""
    - **Сортировка вставками** (Insertion Sort)
    - **Правило Горнера** для вычисления многочлена
    - **Умножение двух матриц** (в данной работе реализован **алгоритм Штрассена**)
    """)


elif app_mode == "Анализ алгоритма: Сортировка вставками":
    st.header("Анализ алгоритма: Сортировка вставками (Insertion Sort)")

    st.subheader("1. Псевдокод алгоритма")
    st.code("""
INSERTION-SORT(A)
1 for j = 2 to A.length
2     key = A[j]
3     // Вставка A[j] в отсортированную последовательность A[1..j-1]
4     i = j - 1
5     while i > 0 and A[i] > key
6         A[i+1] = A[i]
7         i = i - 1
8     A[i+1] = key
    """, language='plaintext')

    st.subheader("2. Доказательство инварианта цикла")
    st.markdown("""
    **Инвариант цикла:** В начале каждой итерации внешнего цикла `for` (строки 1-8) подмассив `A[1..j-1]` содержит те же элементы, что и исходно, но в отсортированном порядке.
    """)
    st.markdown("""
    - **Инициализация:** Перед первой итерацией `j=2`. Подмассив `A[1..1]` состоит из одного элемента, который, очевидно, является отсортированным. Условие выполняется.

    - **Сохранение:** Допустим, что перед итерацией с некоторым значением `j` подмассив `A[1..j-1]` отсортирован. В теле цикла (строки 4-7) внутренний цикл `while` сдвигает элементы `A[j-1], A[j-2], ...` вправо до тех пор, пока не найдет правильную позицию для `key` (исходного `A[j]`). Затем `key` вставляется на свое место (строка 8). В результате подмассив `A[1..j]` будет содержать те же элементы, что и до итерации, но уже в отсортированном порядке. Когда `j` увеличится на 1 в следующей итерации, инвариант для нового, увеличенного подмассива `A[1..j-1]` снова будет истинным.

    - **Завершение:** Цикл завершается, когда `j` становится равным `A.length + 1`. В этот момент, согласно инварианту, подмассив `A[1..A.length]` содержит исходные элементы в отсортированном порядке. Это означает, что весь массив отсортирован, и алгоритм работает корректно.
    """)

    st.subheader("3. Анализ асимптотической сложности")
    st.markdown("""
    Анализ основан на подсчете элементарных операций в псевдокоде. Время выполнения каждой строки `i` обозначим как константу `c_i`.
    """)
    df_data = {
        'Строка': ['1: for j = 2 to n', '2: key = A[j]', '4: i = j - 1', '5: while ...', '6: A[i+1] = A[i]',
                   '7: i = i - 1', '8: A[i+1] = key'],
        'Стоимость': ['c₁', 'c₂', 'c₄', 'c₅', 'c₆', 'c₇', 'c₈'],
        'Повторения': ['n', 'n-1', 'n-1', 'Σ(tⱼ) for j=2 to n', 'Σ(tⱼ-1) for j=2 to n', 'Σ(tⱼ-1) for j=2 to n', 'n-1']
    }
    df = pd.DataFrame(df_data)
    st.table(df)
    st.markdown("""
    где `n = A.length`, а `tⱼ` — это количество проверок условия в цикле `while` для данного `j`.
    """)

    st.markdown("""
    **Худший случай:**
    Худший случай наступает, когда массив отсортирован в обратном порядке. В этом случае для каждого `j` элемент `key` приходится сравнивать со всеми элементами в отсортированном подмассиве `A[1..j-1]`. Таким образом, `tⱼ = j`.
    """)
    st.latex(r'''
    T(n) = c_1 n + c_2(n-1) + c_4(n-1) + c_5 \sum_{j=2}^{n} j + c_6 \sum_{j=2}^{n} (j-1) + c_7 \sum_{j=2}^{n} (j-1) + c_8(n-1)
    ''')
    st.markdown("Суммы вычисляются как `n(n+1)/2 - 1` и `(n-1)n/2` соответственно. После упрощения получаем:")
    st.latex(r'''
    T(n) = \left(\frac{c_5}{2} + \frac{c_6}{2} + \frac{c_7}{2}\right)n^2 + \left(c_1+c_2+c_4+\frac{c_5}{2}-\frac{c_6}{2}-\frac{c_7}{2}+c_8\right)n - (c_2+c_4+c_5)
    ''')
    st.markdown("""
    Это квадратичная функция от `n` вида `an² + bn + c`. Следовательно, асимптотическая сложность в худшем случае:
    """)
    st.success(r'$T(n) = \Theta(n^2)$')

elif app_mode == "Анализ алгоритма: Правило Горнера":
    st.header("Анализ алгоритма: Правило Горнера")

    st.subheader("1. Псевдокод алгоритма")
    st.markdown("Правило Горнера используется для эффективного вычисления значения многочлена:")
    st.latex(r"P(x) = a_n x^n + a_{n-1}x^{n-1} + \dots + a_1 x + a_0")
    st.markdown("Его можно представить в виде:")
    st.latex(r"P(x) = a_0 + x(a_1 + x(a_2 + \dots + x(a_{n-1} + a_n x)\dots))")
    st.code("""
HORNER(A, x) // A - массив коэффициентов [a_0, a_1, ..., a_n]
1 y = 0
2 i = n
3 while i >= 0
4     y = A[i] + x * y
5     i = i - 1
6 return y
    """, language='plaintext')

    st.subheader("2. Доказательство инварианта цикла")
    st.markdown(r"""
    **Инвариант цикла:** В начале каждой итерации цикла `while` (строки 3-5), `y` равно значению многочлена, составленного из коэффициентов `A[i+1...n]` с переменной `x`. То есть:
    $y = \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k$
    """)
    st.markdown("""
    - **Инициализация:** Перед первой итерацией `i = n` и `y = 0`. Инвариант утверждает, что `y` равно значению многочлена с коэффициентами `A[n+1...n]`. Это пустой набор коэффициентов, и значение такого многочлена равно 0. Условие выполняется.

    - **Сохранение:** Допустим, перед итерацией с некоторым `i` инвариант истинен. В теле цикла (строка 4) `y` обновляется: `y_new = A[i] + x * y_old`.
    Подставим значение `y_old` из инварианта:
    $y_{new} = a_i + x \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k = a_i + \sum_{k=0}^{n-i-1} a_{k+i+1} x^{k+1}$
    Сделаем замену `j = k+1`:
    $y_{new} = a_i + \sum_{j=1}^{n-i} a_{j+i} x^j = \sum_{j=0}^{n-i} a_{j+i} x^j$.
    Это в точности значение многочлена для коэффициентов `A[i...n]`. На следующей итерации `i` уменьшится на 1, и инвариант снова будет истинным для нового `i`.

    - **Завершение:** Цикл завершается, когда `i = -1`. Согласно инварианту, `y` равно значению многочлена с коэффициентами `A[0...n]`, что является исходным многочленом $P(x)$. Алгоритм работает корректно.
    """)

    st.subheader("3. Анализ асимптотической сложности")
    st.markdown("""
    Это простой итеративный алгоритм. Цикл `while` выполняется `n+1` раз (для `i` от `n` до `0`). Внутри цикла выполняются одна операция умножения и одна операция сложения, которые занимают константное время `c`.
    """)
    st.latex(r"T(n) = \sum_{i=0}^{n} c = c \cdot (n+1)")
    st.markdown("""
    Рост времени выполнения линейно зависит от `n` (степени многочлена). Следовательно, асимптотическая сложность:
    """)
    st.success(r'$T(n) = \Theta(n)$')


elif app_mode == "Анализ алгоритма: Умножение матриц (Штрассен)":
    st.header("Анализ алгоритма: Умножение матриц (метод Штрассена)")

    st.subheader("1. Псевдокод и описание алгоритма")
    st.markdown(r"""
    Алгоритм Штрассена — это рекурсивный алгоритм умножения матриц, основанный на принципе "разделяй и властвуй". Он позволяет перемножить две матрицы $n \times n$ быстрее, чем стандартный алгоритм со сложностью $\Theta(n^3)$.

    **Шаг 1: Разделение**
    Если размер матриц $n > 1$, то матрицы A, B и C (где $C = A \cdot B$) делятся на четыре подматрицы размером $(n/2) \times (n/2)$ каждая:
    """)
    st.latex(r'''
    A = \begin{pmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{pmatrix}, \quad
    B = \begin{pmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \end{pmatrix}, \quad
    C = \begin{pmatrix} C_{11} & C_{12} \\ C_{21} & C_{22} \end{pmatrix}
    ''')

    st.markdown(r"""
    **Шаг 2: Вычисление промежуточных матриц**
    Ключевая идея Штрассена — выполнить только **7** рекурсивных умножений вместо 8, как в стандартном рекурсивном подходе. Для этого вычисляются 7 промежуточных матриц $P_1, \dots, P_7$ размером $(n/2) \times (n/2)$:
    """)
    st.latex(r'''
    P_1 = A_{11} \cdot (B_{12} - B_{22}) \\
    P_2 = (A_{11} + A_{12}) \cdot B_{22} \\
    P_3 = (A_{21} + A_{22}) \cdot B_{11} \\
    P_4 = A_{22} \cdot (B_{21} - B_{11}) \\
    P_5 = (A_{11} + A_{22}) \cdot (B_{11} + B_{22}) \\
    P_6 = (A_{12} - A_{22}) \cdot (B_{21} + B_{22}) \\
    P_7 = (A_{11} - A_{21}) \cdot (B_{11} + B_{12})
    ''')
    st.markdown("Эти шаги требуют 10 сложений и вычитаний матриц размера $(n/2) \times (n/2)$.")

    st.markdown(r"""
    **Шаг 3: Комбинирование**
    Результаты $C_{ij}$ вычисляются путем сложения и вычитания промежуточных матриц $P_i$:
    """)
    st.latex(r'''
    C_{11} = P_5 + P_4 - P_2 + P_6 \\
    C_{12} = P_1 + P_2 \\
    C_{21} = P_3 + P_4 \\
    C_{22} = P_5 + P_1 - P_3 - P_7
    ''')
    st.markdown("Этот шаг требует 8 сложений и вычитаний матриц размера $(n/2) \times (n/2)$.")

    st.subheader("2. Анализ асимптотической сложности")
    st.markdown(r"""
    Поскольку алгоритм рекурсивный, его временная сложность описывается рекуррентным соотношением.

    - **7** рекурсивных вызовов для умножения матриц размера $(n/2) \times (n/2)$. Время: $7 \cdot T(n/2)$.
    - **18** операций сложения/вычитания матриц размера $(n/2) \times (n/2)$. Сложение двух матриц $k \times k$ занимает $\Theta(k^2)$ времени. Таким образом, эти операции занимают $18 \cdot \Theta((n/2)^2) = \Theta(n^2)$.

    Рекуррентное соотношение для времени работы алгоритма Штрассена:
    """)
    st.latex(r"T(n) = 7 \cdot T(n/2) + \Theta(n^2)")

    st.markdown("---")
    st.subheader("Метод дерева рекурсии")
    st.markdown(r"""
    Построим дерево рекурсии для анализа соотношения $T(n) = 7T(n/2) + cn^2$.
    - **Корень (уровень 0):** Имеет стоимость $cn^2$.
    - **Уровень 1:** 7 дочерних узлов, каждый для подзадачи размера $n/2$. Стоимость каждого узла $c(n/2)^2$. Общая стоимость уровня: $7 \cdot c(n/2)^2 = \frac{7}{4}cn^2$.
    - **Уровень i:** $7^i$ узлов, каждый для подзадачи размера $n/2^i$. Общая стоимость уровня: $7^i \cdot c(n/2^i)^2 = (\frac{7}{4})^i cn^2$.
    - **Глубина дерева:** $k = \log_2 n$.
    - **Количество листьев:** $7^{\log_2 n} = n^{\log_2 7}$. Стоимость в листьях (базовый случай) $T(1) \cdot n^{\log_2 7} = \Theta(n^{\log_2 7})$.

    Полная стоимость — это сумма стоимостей на всех уровнях:
    """)
    st.latex(r'''
    T(n) = \sum_{i=0}^{\log_2 n - 1} \left(\frac{7}{4}\right)^i cn^2 + \Theta(n^{\log_2 7})
    ''')
    st.markdown(r"""
    Это возрастающая геометрическая прогрессия, поэтому итоговая стоимость определяется стоимостью на последнем уровне (в листьях).
    """)
    st.latex(r'''
    T(n) = \Theta(n^{\log_2 7})
    ''')

    st.markdown("---")
    st.subheader("Основной метод (Master Theorem)")
    st.markdown(r"""
    Применим основной метод к соотношению $T(n) = 7T(n/2) + \Theta(n^2)$.
    - $a = 7$
    - $b = 2$
    - $f(n) = \Theta(n^2)$

    Вычислим $n^{\log_b a}$:
    """)
    st.latex(r"n^{\log_2 7} \approx n^{2.807}")
    st.markdown(r"""
    Сравним $f(n) = n^2$ с $n^{2.807}$. Нам нужно проверить, выполняется ли $f(n) = O(n^{\log_2 7 - \epsilon})$ для некоторого $\epsilon > 0$.
    Выберем $\epsilon = 0.8$. Тогда $n^{\log_2 7 - \epsilon} \approx n^{2.007}$.
    Так как $f(n) = n^2 = O(n^{2.007})$, мы находимся в **первом случае** основной теоремы.

    Следовательно, решение:
    """)
    st.latex(r"T(n) = \Theta(n^{\log_b a}) = \Theta(n^{\log_2 7})")
    st.success(r"$T(n) = \Theta(n^{\log_2 7}) \approx \Theta(n^{2.807})$")
    st.info(
        "Это значительно лучше, чем $\Theta(n^3)$ для стандартного алгоритма умножения, особенно на больших матрицах.")

# --- НОВЫЙ БЛОК ДЛЯ ДОМАШНЕГО ЗАДАНИЯ ---
elif app_mode == "Домашнее задание: Решение рекуррентных соотношений":
    st.header("🏠 Домашнее задание: Анализ рекуррентных соотношений")
    st.info(
        "Задача: Рассчитать асимптотическую сложность для заданных рекуррентных соотношений с помощью Основной теоремы (Master Theorem).")

    st.subheader("Основная теорема (напоминание)")
    st.markdown(r"""
    Для рекуррентного соотношения вида $T(n) = aT(n/b) + f(n)$:
    1.  Если $f(n) = O(n^{\log_b a - \epsilon})$ для некоторого $\epsilon > 0$, то $T(n) = \Theta(n^{\log_b a})$.
    2.  Если $f(n) = \Theta(n^{\log_b a})$, то $T(n) = \Theta(n^{\log_b a} \log n)$.
    3.  Если $f(n) = \Omega(n^{\log_b a + \epsilon})$ для некоторого $\epsilon > 0$ и если $a f(n/b) \le c f(n)$ для некоторого $c < 1$ и всех достаточно больших $n$, то $T(n) = \Theta(f(n))$.
    """)
    st.markdown("---")

    # --- ЗАДАЧА А ---
    st.subheader("а. Решение для T(n) = 2T(n/4) + 1")
    st.latex(r"T(n) = 2T(n/4) + 1")
    st.markdown(r"""
    - **Определяем параметры:**
      - $a = 2$
      - $b = 4$
      - $f(n) = 1$
    - **Вычисляем критический показатель:**
      - $n^{\log_b a} = n^{\log_4 2} = n^{1/2} = \sqrt{n}$
    - **Сравниваем $f(n)$ и $n^{\log_b a}$:**
      - Сравниваем $f(n) = 1$ и $n^{0.5}$.
      - Очевидно, что $1 = O(n^{0.5 - \epsilon})$ при $\epsilon = 0.5$.
    - **Вывод:** Применяем **Случай 1** Основной теоремы.
    """)
    st.success(r"**Ответ:** $T(n) = \Theta(n^{\log_b a}) = \Theta(\sqrt{n})$")
    st.markdown("---")

    # --- ЗАДАЧА Б ---
    st.subheader(r"б. Решение для T(n) = 2T(n/4) + \sqrt{n}")
    st.latex(r"T(n) = 2T(n/4) + \sqrt{n}")
    st.markdown(r"""
    - **Определяем параметры:**
      - $a = 2$
      - $b = 4$
      - $f(n) = \sqrt{n} = n^{0.5}$
    - **Вычисляем критический показатель:**
      - $n^{\log_b a} = n^{\log_4 2} = n^{0.5}$
    - **Сравниваем $f(n)$ и $n^{\log_b a}$:**
      - Сравниваем $f(n) = n^{0.5}$ и $n^{0.5}$.
      - Функции асимптотически равны: $f(n) = \Theta(n^{\log_b a})$.
    - **Вывод:** Применяем **Случай 2** Основной теоремы.
    """)
    st.success(r"**Ответ:** $T(n) = \Theta(n^{\log_b a} \log n) = \Theta(\sqrt{n} \log n)$")
    st.markdown("---")

    # --- ЗАДАЧА В ---
    st.subheader("в. Решение для T(n) = 2T(n/4) + n")
    st.latex(r"T(n) = 2T(n/4) + n")
    st.markdown(r"""
    - **Определяем параметры:**
      - $a = 2$
      - $b = 4$
      - $f(n) = n$
    - **Вычисляем критический показатель:**
      - $n^{\log_b a} = n^{\log_4 2} = n^{0.5}$
    - **Сравниваем $f(n)$ и $n^{\log_b a}$:**
      - Сравниваем $f(n) = n^1$ и $n^{0.5}$.
      - $n = \Omega(n^{0.5 + \epsilon})$ при $\epsilon = 0.5$.
    - **Проверяем условие регулярности для Случая 3:**
      - $a f(n/b) \le c f(n)$ для $c < 1$?
      - $2 \cdot (n/4) \le c \cdot n$
      - $n/2 \le c \cdot n$
      - Это неравенство выполняется при $c = 1/2$, что меньше 1. Условие выполнено.
    - **Вывод:** Применяем **Случай 3** Основной теоремы.
    """)
    st.success(r"**Ответ:** $T(n) = \Theta(f(n)) = \Theta(n)$")
    st.markdown("---")

    # --- ЗАДАЧА Г ---
    st.subheader(r"г. Решение для T(n) = 2T(n/4) + n²")
    st.latex(r"T(n) = 2T(n/4) + n^2")
    st.markdown(r"""
    - **Определяем параметры:**
      - $a = 2$
      - $b = 4$
      - $f(n) = n^2$
    - **Вычисляем критический показатель:**
      - $n^{\log_b a} = n^{\log_4 2} = n^{0.5}$
    - **Сравниваем $f(n)$ и $n^{\log_b a}$:**
      - Сравниваем $f(n) = n^2$ и $n^{0.5}$.
      - $n^2 = \Omega(n^{0.5 + \epsilon})$ при $\epsilon = 1.5$.
    - **Проверяем условие регулярности для Случая 3:**
      - $a f(n/b) \le c f(n)$ для $c < 1$?
      - $2 \cdot (n/4)^2 \le c \cdot n^2$
      - $2 \cdot (n^2/16) \le c \cdot n^2$
      - $n^2/8 \le c \cdot n^2$
      - Это неравенство выполняется при $c = 1/8$, что меньше 1. Условие выполнено.
    - **Вывод:** Применяем **Случай 3** Основной теоремы.
    """)
    st.success(r"**Ответ:** $T(n) = \Theta(f(n)) = \Theta(n^2)$")


    #"Общее время (T(n)) для решения задачи размером n равно сумме времени
    # на решение семи подзадач размером n/2 (7T(n/2)) ПЛЮС
    # время на разделение
    # исходной задачи и объединение результатов,
    # которое растет пропорционально
    # квадрату размера задачи (Θ(n²)